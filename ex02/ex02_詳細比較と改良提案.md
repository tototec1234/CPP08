# MutantStack (ex02) 詳細比較レポートと改良実装提案

## 目次
1. [課題要件の確認](#課題要件の確認)
2. [実装詳細比較](#実装詳細比較)
3. [コード分析](#コード分析)
4. [改良実装提案](#改良実装提案)
5. [テストコード提案](#テストコード提案)

---

## 課題要件の確認

### 必須要件（課題書より）
1. **`std::stack`を基に実装**（"It will be implemented in terms of a std::stack"）
2. **すべてのメンバ関数を提供**（"It will offer all its member functions"）
3. **追加機能：イテレータ**（"plus an additional feature: iterators"）
4. **独自のテストコードを記述**

### 要件解釈
- `std::stack`を**継承**することで、すべてのメンバ関数を自動的に提供可能
- イテレータは`begin()`と`end()`を提供することが想定される
- 課題書のテスト例では`const_iterator`は使用されていないため、**必須ではない**

---

## 実装詳細比較

### 1. CPP08/sama_ex02 の実装

#### 特徴
- **シンプルで明快な実装**
- テンプレートパラメータは型`T`のみ
- 内部コンテナはデフォルトの`std::deque<T>`を使用
- デバッグ用のコンストラクタ出力を含む

#### コード構造
```cpp
template<typename T>
class MutantStack : public std::stack<T>
{
    typedef typename std::stack<T>::container_type::iterator iterator;
    iterator begin();
    iterator end();
};
```

#### メリット
✅ **要件を満たす最小限の実装**（KISS原則）  
✅ コードが読みやすく理解しやすい  
✅ `std::stack`の標準動作に完全に準拠  
✅ テンプレート実装を`.tpp`に分離（推奨パターン）  

#### デメリット
⚠️ `const_iterator`が提供されていない  
⚠️ カスタムコンテナ（例：`std::list`）を指定できない  
⚠️ デバッグ出力が含まれている（学習用としては良いが、本番コードでは削除すべき）  

---

### 2. 42-yerevan-cpp/b_ex02 の実装

#### 特徴
- **より柔軟な実装**
- テンプレートパラメータに`Container`を追加可能
- `const_iterator`を提供
- `const`バージョンの`begin()`/`end()`を実装

#### コード構造
```cpp
template <typename T, typename Container = std::deque<T> >
class MutantStack : public std::stack<T, Container>
{
    typedef typename std::stack<T, Container>::container_type::iterator iterator;
    typedef typename std::stack<T, Container>::container_type::const_iterator const_iterator;
    
    iterator begin(void);
    iterator end(void);
    const_iterator begin(void) const;
    const_iterator end(void) const;
};
```

#### メリット
✅ **`const_iterator`サポート**（実用的）  
✅ **カスタムコンテナを指定可能**（柔軟性）  
✅ `const`オブジェクトでもイテレーション可能  
✅ 標準ライブラリの設計パターンに準拠  

#### デメリット
⚠️ `const_iterator begin() const`の実装に問題の可能性  
   - `this->c.begin()`は、`c`が`const`でない限り`iterator`を返す可能性がある  
   - 正しくは：`return static_cast<const container_type&>(this->c).begin();`  

#### 実装上の懸念点

**問題のあるコード（b_ex02）：**
```cpp
template<typename T, typename Container>
typename std::stack<T, Container>::container_type::const_iterator 
MutantStack<T, Container>::begin(void) const
{
    return (this->c.begin());  // ⚠️ 問題：cはconstでないため、iteratorが返る可能性
}
```

**正しい実装：**
```cpp
template<typename T, typename Container>
typename std::stack<T, Container>::container_type::const_iterator 
MutantStack<T, Container>::begin(void) const
{
    // cをconst参照としてキャストすることで、const_iteratorが確実に返される
    return (static_cast<const container_type&>(this->c).begin());
}
```

---

## コード分析

### 共通点

両実装とも以下の点で正しい：
1. ✅ `std::stack`を継承
2. ✅ 内部コンテナ`c`（保護メンバ）にアクセス
3. ✅ `container_type::iterator`を型エイリアスとして定義
4. ✅ `begin()`と`end()`を実装

### 相違点

| 項目 | sama_ex02 | b_ex02 |
|------|-----------|--------|
| テンプレートパラメータ | `T`のみ | `T, Container` |
| `const_iterator` | ❌ なし | ✅ あり |
| `const`メンバ関数 | ❌ なし | ✅ あり |
| カスタムコンテナ対応 | ❌ なし | ✅ あり |
| コードの複雑度 | 低 | 中 |
| 実用性 | 中 | 高 |

### 課題要件への適合度

| 要件 | sama_ex02 | b_ex02 |
|------|-----------|--------|
| `std::stack`基盤 | ✅ 完璧 | ✅ 完璧 |
| 全メンバ関数提供 | ✅ 継承により自動提供 | ✅ 継承により自動提供 |
| イテレータ提供 | ✅ `begin()`/`end()` | ✅ `begin()`/`end()` + `const`版 |
| **課題書の必須要件** | ✅ **完全に満たす** | ✅ **完全に満たす** |

**結論**: 両実装とも課題要件を**完全に満たしている**。

---

## 改良実装提案

### 設計方針

1. **課題書の必須要件を満たす**
   - `std::stack`を継承
   - イテレータ（`begin()`, `end()`）を提供

2. **実用的な拡張機能を追加**（課題制限を超える部分はコメント化）
   - `const_iterator`サポート
   - カスタムコンテナ対応
   - リバースイテレータ（参考実装）

3. **コード品質の向上**
   - `const`メンバ関数の正しい実装
   - デバッグ出力の削除（または条件コンパイル）

### 提案実装：MutantStack.hpp

```cpp
#ifndef MUTANTSTACK_HPP
#define MUTANTSTACK_HPP

#include <stack>

/**
 * @brief MutantStack - std::stackをイテレート可能にしたコンテナアダプタ
 * 
 * std::stackはLIFO（後入先出）のデータ構造を提供するが、イテレータを提供しない。
 * このクラスはstd::stackを継承し、イテレータ機能を追加する。
 * 
 * 課題要件:
 * - std::stackを基に実装
 * - すべてのメンバ関数を提供（継承により自動提供）
 * - イテレータを追加機能として提供
 */
template<typename T>
class MutantStack : public std::stack<T>
{
public:
    // ========== コンストラクタ・デストラクタ ==========
    
    /**
     * @brief デフォルトコンストラクタ
     * std::stackのデフォルトコンストラクタを呼び出す
     */
    MutantStack();
    
    /**
     * @brief コピーコンストラクタ
     * @param src コピー元のMutantStack
     */
    MutantStack(const MutantStack& src);
    
    /**
     * @brief デストラクタ
     * std::stackのデストラクタが自動的に呼び出される
     */
    ~MutantStack();
    
    /**
     * @brief コピー代入演算子
     * @param src コピー元のMutantStack
     * @return 自身への参照
     */
    MutantStack& operator=(const MutantStack& src);

    // ========== イテレータ型定義（課題必須要件） ==========
    
    /**
     * @brief イテレータ型
     * std::stackの内部コンテナ（デフォルトはstd::deque）のイテレータ型
     */
    typedef typename std::stack<T>::container_type::iterator iterator;

    // ========== イテレータ関数（課題必須要件） ==========
    
    /**
     * @brief 先頭イテレータを取得
     * @return 内部コンテナの先頭イテレータ
     */
    iterator begin();
    
    /**
     * @brief 末尾イテレータを取得
     * @return 内部コンテナの末尾イテレータ
     */
    iterator end();

    // ========== 拡張機能（課題制限を超える部分 - コメント化） ==========
    
    /* 
     * 【注意】以下の機能は課題の必須要件を超えるため、参考実装としてコメント化
     * 
     * 理由：
     * - 課題書では"iterators"（複数形）と書かれているが、テスト例ではbegin()とend()のみ使用
     * - const_iteratorやreverse_iteratorは課題の必須要件ではない
     * - ただし、実用的なコードではこれらを提供することが推奨される
     */
    
    /*
    // カスタムコンテナ対応（柔軟性向上）
    template<typename Container = std::deque<T>>
    class MutantStack : public std::stack<T, Container> { ... };
    
    // const_iterator型定義
    typedef typename std::stack<T>::container_type::const_iterator const_iterator;
    
    // const_iterator関数（constオブジェクトでもイテレーション可能）
    const_iterator begin() const;
    const_iterator end() const;
    
    // リバースイテレータ（参考実装）
    typedef typename std::stack<T>::container_type::reverse_iterator reverse_iterator;
    typedef typename std::stack<T>::container_type::const_reverse_iterator const_reverse_iterator;
    
    reverse_iterator rbegin();
    reverse_iterator rend();
    const_reverse_iterator rbegin() const;
    const_reverse_iterator rend() const;
    */
};

// テンプレート実装を.tppファイルからインクルード
#include "MutantStack.tpp"

#endif
```

### 提案実装：MutantStack.tpp

```cpp
#include "MutantStack.hpp"

/* ************************************************************************** */
// コンストラクタ・デストラクタの実装
/* ************************************************************************** */

template<typename T>
MutantStack<T>::MutantStack() : std::stack<T>()
{
}

template<typename T>
MutantStack<T>::MutantStack(const MutantStack& src) : std::stack<T>(src)
{
}

template<typename T>
MutantStack<T>::~MutantStack()
{
}

template<typename T>
MutantStack<T>& MutantStack<T>::operator=(const MutantStack& src)
{
    if (this != &src)
    {
        // std::stackの保護メンバc（内部コンテナ）にアクセス
        // 継承により派生クラスからアクセス可能
        this->c = src.c;
    }
    return *this;
}

/* ************************************************************************** */
// イテレータ関数の実装
/* ************************************************************************** */

template<typename T>
typename MutantStack<T>::iterator MutantStack<T>::begin()
{
    // std::stackは保護メンバとして内部コンテナcを保持
    // 継承により派生クラスからアクセス可能
    return this->c.begin();
}

template<typename T>
typename MutantStack<T>::iterator MutantStack<T>::end()
{
    return this->c.end();
}

/* ************************************************************************** */
// 拡張機能の実装（課題制限を超える部分 - コメント化）
/* ************************************************************************** */

/*
template<typename T>
typename MutantStack<T>::const_iterator MutantStack<T>::begin() const
{
    // 重要：cをconst参照としてキャストすることで、const_iteratorが確実に返される
    return static_cast<const typename std::stack<T>::container_type&>(this->c).begin();
}

template<typename T>
typename MutantStack<T>::const_iterator MutantStack<T>::end() const
{
    return static_cast<const typename std::stack<T>::container_type&>(this->c).end();
}

template<typename T>
typename MutantStack<T>::reverse_iterator MutantStack<T>::rbegin()
{
    return this->c.rbegin();
}

template<typename T>
typename MutantStack<T>::reverse_iterator MutantStack<T>::rend()
{
    return this->c.rend();
}

template<typename T>
typename MutantStack<T>::const_reverse_iterator MutantStack<T>::rbegin() const
{
    return static_cast<const typename std::stack<T>::container_type&>(this->c).rbegin();
}

template<typename T>
typename MutantStack<T>::const_reverse_iterator MutantStack<T>::rend() const
{
    return static_cast<const typename std::stack<T>::container_type&>(this->c).rend();
}
*/
```

### 実装のポイント

1. **課題必須要件のみ実装**
   - `std::stack`継承
   - `iterator`型定義
   - `begin()`/`end()`実装

2. **拡張機能はコメント化**
   - `const_iterator`
   - カスタムコンテナ対応
   - リバースイテレータ
   - 理由を明記

3. **コード品質**
   - 適切なコメント
   - 自己代入チェック
   - `const`正性

---

## const_iterator のユースケース

### なぜ const_iterator が必要か？

`const_iterator`は、**読み取り専用のイテレーション**を提供し、**const性を保証**するための重要な機能です。

### 主なユースケース

#### 1. **const オブジェクトのイテレーション**

`const`オブジェクトに対してイテレーションを行う場合、通常の`iterator`は使用できません。

```cpp
// const_iteratorがない場合の問題
void printStack(const MutantStack<int>& stack)
{
    // ❌ エラー: const オブジェクトに対して非constメンバ関数を呼べない
    // MutantStack<int>::iterator it = stack.begin();  // コンパイルエラー！
    
    // ✅ const_iteratorがあれば可能
    MutantStack<int>::const_iterator it = stack.begin();
    MutantStack<int>::const_iterator ite = stack.end();
    
    while (it != ite)
    {
        std::cout << *it << " ";  // 読み取りのみ（*itの変更は不可）
        ++it;
    }
}

int main()
{
    const MutantStack<int> stack;
    stack.push(1);  // ❌ エラー: const オブジェクトは変更不可
    printStack(stack);  // ✅ const_iteratorがあれば可能
}
```

#### 2. **読み取り専用のアルゴリズム適用**

標準アルゴリズムや関数テンプレートで、要素を変更せずに処理する場合：

```cpp
#include <algorithm>
#include <numeric>

// スタックの要素を合計する（変更不要）
int sumStack(const MutantStack<int>& stack)
{
    // ✅ const_iteratorを使用して、意図的に読み取り専用であることを明示
    MutantStack<int>::const_iterator begin = stack.begin();
    MutantStack<int>::const_iterator end = stack.end();
    
    return std::accumulate(begin, end, 0);
}

// スタックに特定の値が含まれているか確認
bool contains(const MutantStack<int>& stack, int value)
{
    MutantStack<int>::const_iterator it = std::find(stack.begin(), stack.end(), value);
    return it != stack.end();
}

// スタックの内容を別のコンテナにコピー（元のスタックは変更しない）
void copyToVector(const MutantStack<int>& stack, std::vector<int>& vec)
{
    vec.clear();
    vec.assign(stack.begin(), stack.end());  // const_iteratorからコピー
}
```

#### 3. **const メンバ関数の実装**

`const`メンバ関数内でイテレーションする場合：

```cpp
template<typename T>
class MutantStack : public std::stack<T>
{
public:
    // constメンバ関数: スタックの内容を表示（変更しない）
    void print() const
    {
        // ❌ 通常のiteratorは使えない（constメンバ関数内）
        // iterator it = this->c.begin();  // エラー
        
        // ✅ const_iteratorを使用
        const_iterator it = this->begin();  // const版のbegin()が必要
        const_iterator ite = this->end();
        
        while (it != ite)
        {
            std::cout << *it << " ";
            ++it;
        }
    }
    
    // スタックのサイズを返す（変更しない）
    size_t count(int value) const
    {
        size_t count = 0;
        for (const_iterator it = begin(); it != end(); ++it)
        {
            if (*it == value)
                count++;
        }
        return count;
    }
};
```

#### 4. **関数の引数として const 参照を受け取る**

関数が`const`参照でコンテナを受け取る場合、内部でイテレーションするには`const_iterator`が必要：

```cpp
// 2つのスタックを比較（どちらも変更しない）
bool areEqual(const MutantStack<int>& stack1, const MutantStack<int>& stack2)
{
    if (stack1.size() != stack2.size())
        return false;
    
    MutantStack<int>::const_iterator it1 = stack1.begin();
    MutantStack<int>::const_iterator it2 = stack2.begin();
    MutantStack<int>::const_iterator end1 = stack1.end();
    
    while (it1 != end1)
    {
        if (*it1 != *it2)  // 読み取りのみ
            return false;
        ++it1;
        ++it2;
    }
    return true;
}
```

#### 5. **意図の明確化と型安全性**

コードの意図を明確にし、誤って要素を変更することを防ぎます：

```cpp
void processStack(const MutantStack<int>& stack)
{
    // ✅ const_iteratorを使用 = 「読み取り専用」であることを明確に
    for (MutantStack<int>::const_iterator it = stack.begin(); it != stack.end(); ++it)
    {
        // *it = 100;  // ❌ コンパイルエラー: const_iteratorは変更を禁止
        std::cout << *it << std::endl;  // ✅ 読み取りのみ
    }
    
    // 通常のiteratorとの比較
    MutantStack<int> mutableStack;
    for (MutantStack<int>::iterator it = mutableStack.begin(); it != mutableStack.end(); ++it)
    {
        *it = 100;  // ✅ 可能: 通常のiteratorは変更可能
        std::cout << *it << std::endl;
    }
}
```

### const_iterator がない場合の問題

```cpp
template<typename T>
class MutantStack : public std::stack<T>
{
    // const_iteratorがない実装
    iterator begin();  // 非const版のみ
    iterator end();
};

void process(const MutantStack<int>& stack)
{
    // ❌ コンパイルエラー！
    // const オブジェクトに対して非constメンバ関数を呼べない
    MutantStack<int>::iterator it = stack.begin();  // エラー
}
```

### 実用的な例：ログ機能

```cpp
// スタックの内容をログに出力（変更しない）
void logStackContents(const MutantStack<std::string>& stack, const std::string& tag)
{
    std::cout << "[" << tag << "] Stack contents: ";
    
    // const_iteratorを使用することで、「この関数は読み取り専用」であることを明示
    for (MutantStack<std::string>::const_iterator it = stack.begin(); 
         it != stack.end(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
}

// デバッグ関数（元のデータを変更しない）
void debugPrintStack(const MutantStack<int>& stack)
{
    std::cout << "Stack size: " << stack.size() << std::endl;
    std::cout << "Elements: ";
    
    MutantStack<int>::const_iterator it = stack.begin();
    MutantStack<int>::const_iterator ite = stack.end();
    
    while (it != ite)
    {
        std::cout << *it;
        ++it;
        if (it != ite)
            std::cout << ", ";
    }
    std::cout << std::endl;
}
```

### まとめ

| ユースケース | 必要性 |
|------------|--------|
| `const`オブジェクトのイテレーション | ⭐⭐⭐⭐⭐ 必須 |
| `const`メンバ関数でのイテレーション | ⭐⭐⭐⭐⭐ 必須 |
| `const`参照引数でのイテレーション | ⭐⭐⭐⭐⭐ 必須 |
| 読み取り専用アルゴリズムの適用 | ⭐⭐⭐⭐ 強く推奨 |
| コードの意図明確化 | ⭐⭐⭐ 推奨 |
| 型安全性の向上 | ⭐⭐⭐⭐ 強く推奨 |

**結論**: `const_iterator`は、**const性を保証し、読み取り専用のイテレーションを提供する重要な機能**です。実用的なコードではほぼ必須といえます。

---

## テストコード提案

### 設計方針

1. **課題書のテスト例を完全に再現**
2. **比較テスト**（`std::list`などと比較）
3. **エッジケーステスト**
4. **型汎用性テスト**（`int`以外）

### 提案実装：main.cpp

```cpp
#include "MutantStack.hpp"
#include <iostream>
#include <list>
#include <vector>

/**
 * @brief 課題書で提供されたテスト例
 * 
 * この関数は課題書のテスト例をそのまま実装している。
 * 出力がstd::listと同じになることを確認するために使用する。
 */
void subject_test()
{
    std::cout << "========== Subject Test (課題書のテスト例) ==========" << std::endl;
    
    MutantStack<int> mstack;
    mstack.push(5);
    mstack.push(17);
    std::cout << mstack.top() << std::endl;  // 期待値: 17
    mstack.pop();
    std::cout << mstack.size() << std::endl;  // 期待値: 1
    mstack.push(3);
    mstack.push(5);
    mstack.push(737);
    mstack.push(0);
    
    MutantStack<int>::iterator it = mstack.begin();
    MutantStack<int>::iterator ite = mstack.end();
    ++it;
    --it;
    while (it != ite)
    {
        std::cout << *it << std::endl;
        ++it;
    }
    
    // std::stackへのコピー（課題書の要件）
    std::stack<int> s(mstack);
    std::cout << "Copied to std::stack, size: " << s.size() << std::endl;
    
    std::cout << std::endl;
}

/**
 * @brief std::listとの比較テスト
 * 
 * 課題書の要件：
 * "MutantStackで最初に実行し、次にMutantStackをstd::listなどの他のコンテナに置き換えて
 * 実行すると、2つの出力は同じになるはずです。"
 */
void comparison_test_with_list()
{
    std::cout << "========== Comparison Test: MutantStack vs std::list ==========" << std::endl;
    
    // MutantStackでの実行
    std::cout << "--- MutantStack output ---" << std::endl;
    {
        MutantStack<int> mstack;
        mstack.push(5);
        mstack.push(17);
        std::cout << mstack.top() << std::endl;
        mstack.pop();
        std::cout << mstack.size() << std::endl;
        mstack.push(3);
        mstack.push(5);
        mstack.push(737);
        mstack.push(0);
        
        MutantStack<int>::iterator it = mstack.begin();
        MutantStack<int>::iterator ite = mstack.end();
        ++it;
        --it;
        while (it != ite)
        {
            std::cout << *it << std::endl;
            ++it;
        }
    }
    
    // std::listでの実行（同等の操作）
    std::cout << "--- std::list output (should be identical) ---" << std::endl;
    {
        std::list<int> lst;
        lst.push_back(5);    // push() → push_back()
        lst.push_back(17);
        std::cout << lst.back() << std::endl;  // top() → back()
        lst.pop_back();      // pop() → pop_back()
        std::cout << lst.size() << std::endl;
        lst.push_back(3);
        lst.push_back(5);
        lst.push_back(737);
        lst.push_back(0);
        
        std::list<int>::iterator it = lst.begin();
        std::list<int>::iterator ite = lst.end();
        ++it;
        --it;
        while (it != ite)
        {
            std::cout << *it << std::endl;
            ++it;
        }
    }
    
    std::cout << std::endl;
}

/**
 * @brief エッジケーステスト
 * 
 * - 空のスタック
 * - 単一要素のスタック
 * - 大量の要素
 */
void edge_case_test()
{
    std::cout << "========== Edge Case Test ==========" << std::endl;
    
    // 1. 空のスタック
    std::cout << "--- Empty stack ---" << std::endl;
    {
        MutantStack<int> emptyStack;
        std::cout << "Empty stack size: " << emptyStack.size() << std::endl;
        std::cout << "Is empty: " << (emptyStack.empty() ? "true" : "false") << std::endl;
        
        // イテレータはbegin() == end()になる
        if (emptyStack.begin() == emptyStack.end())
        {
            std::cout << "begin() == end() for empty stack (correct)" << std::endl;
        }
    }
    
    // 2. 単一要素のスタック
    std::cout << "\n--- Single element stack ---" << std::endl;
    {
        MutantStack<int> singleStack;
        singleStack.push(42);
        std::cout << "Single element: ";
        for (MutantStack<int>::iterator it = singleStack.begin(); it != singleStack.end(); ++it)
        {
            std::cout << *it << std::endl;
        }
    }
    
    // 3. 大量の要素
    std::cout << "\n--- Large stack (1000 elements) ---" << std::endl;
    {
        MutantStack<int> largeStack;
        for (int i = 0; i < 1000; ++i)
        {
            largeStack.push(i);
        }
        std::cout << "Stack size: " << largeStack.size() << std::endl;
        std::cout << "Top element: " << largeStack.top() << std::endl;
        
        // 最初の5つと最後の5つを表示
        MutantStack<int>::iterator it = largeStack.begin();
        std::cout << "First 5 elements: ";
        for (int i = 0; i < 5 && it != largeStack.end(); ++i, ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
    
    std::cout << std::endl;
}

/**
 * @brief 型汎用性テスト
 * 
 * テンプレートの汎用性を確認するため、異なる型でテストする。
 */
void type_genericity_test()
{
    std::cout << "========== Type Genericity Test ==========" << std::endl;
    
    // 1. std::string型
    std::cout << "--- std::string type ---" << std::endl;
    {
        MutantStack<std::string> stringStack;
        stringStack.push("Hello");
        stringStack.push("World");
        stringStack.push("C++");
        stringStack.push("Templates");
        
        std::cout << "String stack contents: ";
        for (MutantStack<std::string>::iterator it = stringStack.begin(); 
             it != stringStack.end(); ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
        std::cout << "Top: " << stringStack.top() << std::endl;
    }
    
    // 2. double型
    std::cout << "\n--- double type ---" << std::endl;
    {
        MutantStack<double> doubleStack;
        doubleStack.push(3.14);
        doubleStack.push(2.71);
        doubleStack.push(1.41);
        
        std::cout << "Double stack contents: ";
        for (MutantStack<double>::iterator it = doubleStack.begin(); 
             it != doubleStack.end(); ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
    
    // 3. イテレータの前後移動テスト
    std::cout << "\n--- Iterator increment/decrement test ---" << std::endl;
    {
        MutantStack<int> testStack;
        testStack.push(1);
        testStack.push(2);
        testStack.push(3);
        testStack.push(4);
        testStack.push(5);
        
        MutantStack<int>::iterator it = testStack.begin();
        std::cout << "Initial: " << *it << std::endl;
        ++it;
        std::cout << "After ++: " << *it << std::endl;
        --it;
        std::cout << "After --: " << *it << std::endl;
        it += 2;
        std::cout << "After += 2: " << *it << std::endl;
    }
    
    std::cout << std::endl;
}

/**
 * @brief コピーセマンティクステスト
 * 
 * コピーコンストラクタと代入演算子が正しく動作することを確認する。
 */
void copy_semantics_test()
{
    std::cout << "========== Copy Semantics Test ==========" << std::endl;
    
    // コピーコンストラクタ
    std::cout << "--- Copy constructor ---" << std::endl;
    {
        MutantStack<int> original;
        original.push(10);
        original.push(20);
        original.push(30);
        
        MutantStack<int> copied(original);
        
        std::cout << "Original size: " << original.size() << std::endl;
        std::cout << "Copied size: " << copied.size() << std::endl;
        
        std::cout << "Original contents: ";
        for (MutantStack<int>::iterator it = original.begin(); it != original.end(); ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
        
        std::cout << "Copied contents: ";
        for (MutantStack<int>::iterator it = copied.begin(); it != copied.end(); ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
    
    // 代入演算子
    std::cout << "\n--- Assignment operator ---" << std::endl;
    {
        MutantStack<int> source;
        source.push(100);
        source.push(200);
        
        MutantStack<int> target;
        target.push(999);  // これは上書きされる
        
        target = source;
        
        std::cout << "Source size: " << source.size() << std::endl;
        std::cout << "Target size: " << target.size() << std::endl;
        
        std::cout << "Target contents: ";
        for (MutantStack<int>::iterator it = target.begin(); it != target.end(); ++it)
        {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
    
    std::cout << std::endl;
}

int main()
{
    // 1. 課題書のテスト例
    subject_test();
    
    // 2. std::listとの比較テスト（課題書の要件）
    comparison_test_with_list();
    
    // 3. エッジケーステスト
    edge_case_test();
    
    // 4. 型汎用性テスト
    type_genericity_test();
    
    // 5. コピーセマンティクステスト
    copy_semantics_test();
    
    return 0;
}
```

### テストコードの特徴

1. **課題要件を完全にカバー**
   - 課題書のテスト例を完全再現
   - `std::list`との比較テスト

2. **包括的なテスト**
   - エッジケース（空、単一要素、大量要素）
   - 型汎用性（`int`, `string`, `double`）
   - コピーセマンティクス

3. **明確な出力**
   - 各テストセクションに説明を付与
   - 期待される動作を明記

---

## まとめ

### 比較結果

| 観点 | sama_ex02 | b_ex02 | 提案実装 |
|------|-----------|--------|----------|
| **課題要件適合** | ✅ 完璧 | ✅ 完璧 | ✅ 完璧 |
| **コードの簡潔性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **実用性** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **拡張性** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 推奨事項

1. **課題提出用**: **sama_ex02のアプローチ**を採用
   - 必須要件のみ実装
   - シンプルで理解しやすい

2. **実用的なコード**: **b_ex02のアプローチ**を採用
   - `const_iterator`サポート
   - カスタムコンテナ対応
   - ただし、`const_iterator`の実装は修正が必要

3. **学習用**: **提案実装**を採用
   - 必須要件を実装
   - 拡張機能をコメントで説明
   - 詳細なドキュメント

### 最終的な推奨実装

課題書の制限内で最良の実装は、**sama_ex02のアプローチ + デバッグ出力の削除 + 適切なコメント**です。

しかし、**実用的な観点**では、**b_ex02のアプローチ（`const_iterator`の実装を修正）**が最適です。

このレポートでは、両方のアプローチを理解し、要件に応じて適切に選択できるよう、詳細な比較と提案を提供しました。
